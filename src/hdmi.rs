// // hdmi.rs
// #![no_std]

// use core::ptr;
// use crate::mailbox; // Import the mailbox module from the crate root
// use crate::mailbox::{mailbox_write, mailbox_read,MAILBOX_BUFFER};



// // These are the standard mailbox property tags for the Raspberry Pi.
// const TAG_ALLOCATE_FRAMEBUFFER: u32 = 0x00040001;
// const TAG_SET_PHYSICAL_WIDTH_HEIGHT: u32 = 0x00048003;
// const TAG_SET_VIRTUAL_WIDTH_HEIGHT: u32 = 0x00048004;
// const TAG_SET_DEPTH: u32 = 0x00048005;
// const TAG_GET_PITCH: u32 = 0x00040008;
// const TAG_END: u32 = 0;

// const MAILBOX_CHANNEL_PROP: u8 = 8;

// // Define a mailbox buffer for the framebuffer request.
// // We allocate a buffer that holds several tags. In this example, we request:
// //  - A physical resolution of 1024x768
// //  - A virtual resolution equal to the physical resolution
// //  - A color depth of 32 bits per pixel
// //  - And then get the pitch.
// #[repr(C, align(16))]
// pub struct FramebufferRequest {
//     size: u32,
//     req_code: u32,
//     tag1: u32,
//     tag1_buf_size: u32,
//     tag1_req_resp: u32,
//     phys_width: u32,
//     phys_height: u32,
//     tag2: u32,
//     tag2_buf_size: u32,
//     tag2_req_resp: u32,
//     virt_width: u32,
//     virt_height: u32,
//     tag3: u32,
//     tag3_buf_size: u32,
//     tag3_req_resp: u32,
//     depth: u32,
//     tag4: u32,
//     tag4_buf_size: u32,
//     tag4_req_resp: u32,
//     _pitch: u32, // This will be filled with the pitch.
//     tag_end: u32,
// }

// // Helper function: convert a pointer to u32 after shifting right 4 bits.
// fn ptr_to_mailbox_format<T>(ptr: *const T) -> u32 {
//     (ptr as u32) >> 4
// }

// /// Request a framebuffer for HDMI output.
// /// Returns Some((framebuffer_addr, pitch, width, height, depth)) on success.
// pub fn init_hdmi() -> Option<(u32, u32, u32, u32, u32)> {
//     // Set desired parameters.
//     let phys_width: u32 = 1024;
//     let phys_height: u32 = 768;
//     let virt_width: u32 = phys_width;
//     let virt_height: u32 = phys_height;
//     let depth: u32 = 32; // bits per pixel

//     let mut fb_req = FramebufferRequest {
//         size: core::mem::size_of::<FramebufferRequest>() as u32,
//         req_code: 0, // request
//         tag1: TAG_SET_PHYSICAL_WIDTH_HEIGHT,
//         tag1_buf_size: 8,
//         tag1_req_resp: 8,
//         phys_width,
//         phys_height,
//         tag2: TAG_SET_VIRTUAL_WIDTH_HEIGHT,
//         tag2_buf_size: 8,
//         tag2_req_resp: 8,
//         virt_width,
//         virt_height,
//         tag3: TAG_SET_DEPTH,
//         tag3_buf_size: 4,
//         tag3_req_resp: 4,
//         depth,
//         tag4: TAG_ALLOCATE_FRAMEBUFFER,
//         tag4_buf_size: 8,
//         tag4_req_resp: 8,
//         _pitch: 0,
//         tag_end: TAG_END,
//     };

//     // Get pointer to buffer in mailbox format.
//     let ptr = &fb_req as *const FramebufferRequest;
//     let mailbox_ptr = ptr_to_mailbox_format(ptr);

//     // Write to mailbox.
//     mailbox::mailbox_write(MAILBOX_CHANNEL_PROP, mailbox_ptr);
//     // Read response.
//     let response = mailbox::mailbox_read(MAILBOX_CHANNEL_PROP);

//     if response != mailbox_ptr {
//         return None;
//     }

//     // Check if the response indicates success. For the property mailbox,
//     // success is usually indicated by setting the request/response field to 0x80000000.
//     if fb_req.req_code != 0x80000000 {
//         return None;
//     }

//     // The GPU writes the framebuffer address and pitch in the tag for TAG_ALLOCATE_FRAMEBUFFER.
//     // let framebuffer_addr = fb_req.phys_width; // Actually, in many examples, the framebuffer address is returned in place of the width.
//     let framebuffer_addr = fb_req.phys_width & 0x3FFFFFFF;
//     let pitch = fb_req._pitch;
    
//     // For the purpose of this example, we assume success if pitch is non-zero.
//     if pitch == 0 {
//         return None;
//     }
//     Some((framebuffer_addr, pitch, phys_width, phys_height, depth))
// }

#![no_std]

//use core::ptr;
use crate::mailbox::{mailbox_write, mailbox_read, MAILBOX_CHANNEL_PROP};
use core::ptr::write_volatile;

const TAG_SET_PHYS_WH: u32 = 0x00048003;
const TAG_SET_VIRT_WH: u32 = 0x00048004;
const TAG_SET_DEPTH: u32   = 0x00048005;
const TAG_ALLOCATE_FB: u32 = 0x00040001;
const TAG_END: u32         = 0;

#[repr(C, align(16))]
pub struct FramebufferBuffer {
    pub buffer: [u32; 22],
}

pub static mut FB_BUFFER: FramebufferBuffer = FramebufferBuffer {
    buffer: [
        22 * 4,            // Total size in bytes: 22 words * 4 = 88 bytes
        0,                 // Request code (0 for request; firmware sets to 0x80000000 on success)
        TAG_SET_PHYS_WH,   // Tag: Set physical width/height
        8,                 // Value buffer size (in bytes)
        8,                 // Value length (in bytes)
        1024,              // Physical width
        768,               // Physical height
        TAG_SET_VIRT_WH,   // Tag: Set virtual width/height
        8,                 // Value buffer size
        8,                 // Value length
        1024,              // Virtual width
        768,               // Virtual height
        TAG_SET_DEPTH,     // Tag: Set depth
        4,                 // Value buffer size
        4,                 // Value length
        32,                // Color depth (bits per pixel)
        TAG_ALLOCATE_FB,   // Tag: Allocate framebuffer
        8,                 // Value buffer size
        8,                 // Value length
        0,                 // Output: Framebuffer address (will be filled by GPU)
        0,                 // Output: Pitch (bytes per line)
        TAG_END,           // End tag (0)
    ],
};

/// Convert a pointer to mailbox format (shift right by 4)
fn ptr_to_mailbox_format<T>(ptr: *const T) -> u32 {
    (ptr as u32) >> 4
}

/// Initializes HDMI by issuing a mailbox property request for the framebuffer.
/// Returns Some((framebuffer_addr, pitch, width, height, depth)) on success.
pub fn init_hdmi() -> Option<(u32, u32, u32, u32, u32)> {
    // Get pointer to the static mailbox buffer.
    let fb_ptr = unsafe { &FB_BUFFER.buffer as *const u32 };
    let mailbox_ptr = ptr_to_mailbox_format(fb_ptr);

    // Send the mailbox request.
    mailbox_write(MAILBOX_CHANNEL_PROP, mailbox_ptr);
    let response = mailbox_read(MAILBOX_CHANNEL_PROP);

    unsafe {
        // Check that the response matches our mailbox pointer and that the request code
        // was updated to indicate success (0x80000000).
        if response != mailbox_ptr || FB_BUFFER.buffer[1] != 0x80000000 {
            return None;
        }
        // The GPU should write the framebuffer address in word 19 and the pitch in word 20.
        let framebuffer_addr = FB_BUFFER.buffer[19] & 0x3FFFFFFF; // Mask high bits.
        let pitch = FB_BUFFER.buffer[20];
        if framebuffer_addr == 0 || pitch == 0 {
            return None;
        }
        Some((framebuffer_addr, pitch, FB_BUFFER.buffer[5], FB_BUFFER.buffer[6], FB_BUFFER.buffer[15]))
    }
}

// static FONT8X8: [[u8; 8]; 128] = {
//     let mut font = [[0u8; 8]; 128];
//     // Define glyph for 'A' (ASCII 65)
//     font[65] = [
//         0b00011000,
//         0b00100100,
//         0b01000010,
//         0b01000010,
//         0b01111110,
//         0b01000010,
//         0b01000010,
//         0b00000000,
//     ];
//     // Define glyph for 'B' (ASCII 66)
//     font[66] = [
//         0b01111100,
//         0b01000010,
//         0b01000010,
//         0b01111100,
//         0b01000010,
//         0b01000010,
//         0b01111100,
//         0b00000000,
//     ];
//     // More characters can be added...
//     font
// };

static FONT8X8: [[u8; 8]; 128] = {
    let mut font = [[0u8; 8]; 128];
    // 0x00: (null)
    font[0x00] = [0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00];
    // 0x01
    font[0x01] = [0x7E,0x81,0xA5,0x81,0xBD,0x99,0x81,0x7E];
    // 0x02
    font[0x02] = [0x7E,0xFF,0xD7,0xFF,0xFF,0xC3,0xE7,0x7E];
    // 0x03
    font[0x03] = [0x6E,0xFF,0xFF,0xFF,0xFF,0x7B,0x63,0x00];
    // 0x04
    font[0x04] = [0x0C,0x1E,0x3F,0x7F,0x3F,0x1E,0x0C,0x00];
    // 0x05
    font[0x05] = [0x18,0x3C,0x7E,0xFF,0x7E,0x3C,0x18,0x00];
    // 0x06
    font[0x06] = [0x00,0x18,0x3C,0x7E,0x3C,0x18,0x00,0x00];
    // 0x07
    font[0x07] = [0xFF,0xE7,0xC3,0x81,0xC3,0xE7,0xFF,0x00];
    // 0x08
    font[0x08] = [0x00,0x3C,0x66,0xC3,0xC3,0x66,0x3C,0x00];
    // 0x09
    font[0x09] = [0xFF,0xC3,0x99,0xBD,0xBD,0x99,0xC3,0xFF];
    // 0x0A
    font[0x0A] = [0x00,0x66,0x66,0x66,0x66,0x66,0x66,0x00];
    // 0x0B
    font[0x0B] = [0xFF,0xDB,0xC3,0xC3,0xC3,0xC3,0xDB,0xFF];
    // 0x0C
    font[0x0C] = [0x0F,0x1F,0x3F,0x7F,0x3F,0x1F,0x0F,0x00];
    // 0x0D
    font[0x0D] = [0xF0,0xF8,0xFC,0xFE,0xFC,0xF8,0xF0,0x00];
    // 0x0E
    font[0x0E] = [0x00,0x66,0x3C,0x18,0x3C,0x66,0x00,0x00];
    // 0x0F
    font[0x0F] = [0xFF,0xC3,0x99,0xBD,0xBD,0x99,0xC3,0xFF];
    // 0x10
    font[0x10] = [0x3E,0x63,0x73,0x7B,0x6F,0x67,0x3E,0x00];
    // 0x11
    font[0x11] = [0x7C,0x66,0x66,0x7C,0x66,0x66,0x7C,0x00];
    // 0x12
    font[0x12] = [0x3C,0x66,0x60,0x30,0x0C,0x66,0x3C,0x00];
    // 0x13
    font[0x13] = [0x78,0x6C,0x66,0x66,0x66,0x6C,0x78,0x00];
    // 0x14
    font[0x14] = [0xCC,0xCC,0xCC,0xFC,0xCC,0xCC,0xCC,0x00];
    // 0x15
    font[0x15] = [0xF8,0xCC,0xCC,0xF8,0xCC,0xCC,0xF8,0x00];
    // 0x16
    font[0x16] = [0x3C,0x66,0x66,0x66,0x66,0x66,0x3C,0x00];
    // 0x17
    font[0x17] = [0xFC,0x66,0x66,0xFC,0x66,0x66,0xFC,0x00];
    // 0x18
    font[0x18] = [0xFF,0x99,0x99,0x99,0x99,0x99,0xFF,0x00];
    // 0x19
    font[0x19] = [0xF0,0x90,0x90,0x90,0x90,0x90,0xF0,0x00];
    // 0x1A
    font[0x1A] = [0x7E,0x81,0x99,0xBD,0xBD,0x99,0x81,0x7E];
    // 0x1B
    font[0x1B] = [0x3E,0x63,0x41,0x41,0x41,0x63,0x3E,0x00];
    // 0x1C
    font[0x1C] = [0x1C,0x36,0x63,0x63,0x63,0x36,0x1C,0x00];
    // 0x1D
    font[0x1D] = [0xFF,0xC3,0x81,0x81,0x81,0xC3,0xFF,0x00];
    // 0x1E
    font[0x1E] = [0x00,0x66,0xFF,0xFF,0xFF,0xFF,0x66,0x00];
    // 0x1F
    font[0x1F] = [0x06,0x0F,0x3E,0x78,0x3E,0x0F,0x06,0x00];
    // 0x20: Space
    font[0x20] = [0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00];
    // 0x21: !
    font[0x21] = [0x18,0x3C,0x3C,0x18,0x18,0x00,0x18,0x00];
    // 0x22: "
    font[0x22] = [0x36,0x36,0x24,0x00,0x00,0x00,0x00,0x00];
    // 0x23: #
    font[0x23] = [0x36,0x36,0x7F,0x36,0x7F,0x36,0x36,0x00];
    // 0x24: $
    font[0x24] = [0x0C,0x3E,0x03,0x1E,0x30,0x1F,0x0C,0x00];
    // 0x25: %
    font[0x25] = [0x00,0x63,0x33,0x18,0x0C,0x66,0x63,0x00];
    // 0x26: &
    font[0x26] = [0x1C,0x36,0x1C,0x6E,0x3B,0x33,0x6E,0x00];
    // 0x27: '
    font[0x27] = [0x06,0x06,0x04,0x00,0x00,0x00,0x00,0x00];
    // 0x28: (
    font[0x28] = [0x18,0x0C,0x06,0x06,0x06,0x0C,0x18,0x00];
    // 0x29: )
    font[0x29] = [0x06,0x0C,0x18,0x18,0x18,0x0C,0x06,0x00];
    // 0x2A: *
    font[0x2A] = [0x00,0x66,0x3C,0xFF,0x3C,0x66,0x00,0x00];
    // 0x2B: +
    font[0x2B] = [0x00,0x18,0x18,0x7E,0x18,0x18,0x00,0x00];
    // 0x2C: ,
    font[0x2C] = [0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x0C];
    // 0x2D: -
    font[0x2D] = [0x00,0x00,0x00,0x7E,0x00,0x00,0x00,0x00];
    // 0x2E: .
    font[0x2E] = [0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00];
    // 0x2F: /
    font[0x2F] = [0x60,0x30,0x18,0x0C,0x06,0x03,0x01,0x00];
    // 0x30: 0
    font[0x30] = [0x3E,0x63,0x73,0x7B,0x6F,0x67,0x3E,0x00];
    // 0x31: 1
    font[0x31] = [0x18,0x1C,0x1E,0x18,0x18,0x18,0x3E,0x00];
    // 0x32: 2
    font[0x32] = [0x3E,0x63,0x60,0x3C,0x06,0x63,0x7F,0x00];
    // 0x33: 3
    font[0x33] = [0x3E,0x63,0x60,0x3C,0x60,0x63,0x3E,0x00];
    // 0x34: 4
    font[0x34] = [0x70,0x78,0x6C,0x66,0x7F,0x60,0xF0,0x00];
    // 0x35: 5
    font[0x35] = [0x7F,0x03,0x3F,0x60,0x60,0x63,0x3E,0x00];
    // 0x36: 6
    font[0x36] = [0x3C,0x06,0x03,0x3F,0x63,0x63,0x3E,0x00];
    // 0x37: 7
    font[0x37] = [0x7F,0x63,0x30,0x18,0x0C,0x0C,0x0C,0x00];
    // 0x38: 8
    font[0x38] = [0x3E,0x63,0x63,0x3E,0x63,0x63,0x3E,0x00];
    // 0x39: 9
    font[0x39] = [0x3E,0x63,0x63,0x7E,0x60,0x30,0x1E,0x00];
    // 0x3A: :
    font[0x3A] = [0x00,0x18,0x18,0x00,0x00,0x18,0x18,0x00];
    // 0x3B: ;
    font[0x3B] = [0x00,0x18,0x18,0x00,0x00,0x18,0x18,0x0C];
    // 0x3C: <
    font[0x3C] = [0x0E,0x1C,0x38,0x70,0x38,0x1C,0x0E,0x00];
    // 0x3D: =
    font[0x3D] = [0x00,0x00,0x7E,0x00,0x7E,0x00,0x00,0x00];
    // 0x3E: >
    font[0x3E] = [0x70,0x38,0x1C,0x0E,0x1C,0x38,0x70,0x00];
    // 0x3F: ?
    font[0x3F] = [0x3E,0x63,0x63,0x3C,0x18,0x00,0x18,0x00];
    // 0x40: @
    font[0x40] = [0x3E,0x63,0x7B,0x7B,0x7B,0x03,0x1E,0x00];
    // 0x41: A
    font[0x41] = [0x18,0x3C,0x66,0x66,0x7E,0x66,0x66,0x00];
    // 0x42: B
    font[0x42] = [0x3F,0x66,0x66,0x3E,0x66,0x66,0x3F,0x00];
    // 0x43: C
    font[0x43] = [0x3C,0x66,0x03,0x03,0x03,0x66,0x3C,0x00];
    // 0x44: D
    font[0x44] = [0x1F,0x36,0x66,0x66,0x66,0x36,0x1F,0x00];
    // 0x45: E
    font[0x45] = [0x7F,0x46,0x16,0x1E,0x16,0x46,0x7F,0x00];
    // 0x46: F
    font[0x46] = [0x7F,0x46,0x16,0x1E,0x16,0x06,0x0F,0x00];
    // 0x47: G
    font[0x47] = [0x3C,0x66,0x03,0x03,0x73,0x66,0x7C,0x00];
    // 0x48: H
    font[0x48] = [0x66,0x66,0x66,0x7F,0x66,0x66,0x66,0x00];
    // 0x49: I
    font[0x49] = [0x3C,0x18,0x18,0x18,0x18,0x18,0x3C,0x00];
    // 0x4A: J
    font[0x4A] = [0x78,0x30,0x30,0x30,0x33,0x33,0x1E,0x00];
    // 0x4B: K
    font[0x4B] = [0x67,0x66,0x36,0x1E,0x36,0x66,0x67,0x00];
    // 0x4C: L
    font[0x4C] = [0x0F,0x06,0x06,0x06,0x46,0x66,0x7F,0x00];
    // 0x4D: M
    font[0x4D] = [0x63,0x77,0x7F,0x7F,0x6B,0x63,0x63,0x00];
    // 0x4E: N
    font[0x4E] = [0x63,0x67,0x6F,0x7B,0x73,0x63,0x63,0x00];
    // 0x4F: O
    font[0x4F] = [0x1C,0x36,0x63,0x63,0x63,0x36,0x1C,0x00];
    // 0x50: P
    font[0x50] = [0x3F,0x66,0x66,0x3E,0x06,0x06,0x0F,0x00];
    // 0x51: Q
    font[0x51] = [0x1E,0x33,0x33,0x33,0x3B,0x1E,0x38,0x00];
    // 0x52: R
    font[0x52] = [0x3F,0x66,0x66,0x3E,0x36,0x66,0x67,0x00];
    // 0x53: S
    font[0x53] = [0x1E,0x33,0x07,0x0E,0x38,0x33,0x1E,0x00];
    // 0x54: T
    font[0x54] = [0x3F,0x2D,0x0C,0x0C,0x0C,0x0C,0x1E,0x00];
    // 0x55: U
    font[0x55] = [0x33,0x33,0x33,0x33,0x33,0x33,0x3F,0x00];
    // 0x56: V
    font[0x56] = [0x1C,0x36,0x33,0x33,0x33,0x36,0x1C,0x00];
    // 0x57: W
    font[0x57] = [0x63,0x63,0x6B,0x7F,0x7F,0x77,0x63,0x00];
    // 0x58: X
    font[0x58] = [0x63,0x63,0x36,0x1C,0x1C,0x36,0x63,0x00];
    // 0x59: Y
    font[0x59] = [0x33,0x33,0x33,0x1E,0x0C,0x0C,0x1E,0x00];
    // 0x5A: Z
    font[0x5A] = [0x7F,0x63,0x31,0x18,0x4C,0x66,0x7F,0x00];
    // 0x5B: [
    font[0x5B] = [0x1E,0x06,0x06,0x06,0x06,0x06,0x1E,0x00];
    // 0x5C: backslash
    font[0x5C] = [0x03,0x06,0x0C,0x18,0x30,0x60,0xC0,0x00];
    // 0x5D: ]
    font[0x5D] = [0x1E,0x18,0x18,0x18,0x18,0x18,0x1E,0x00];
    // 0x5E: ^
    font[0x5E] = [0x08,0x1C,0x36,0x63,0x00,0x00,0x00,0x00];
    // 0x5F: _
    font[0x5F] = [0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF];
    // 0x60: `
    font[0x60] = [0x0C,0x0C,0x06,0x00,0x00,0x00,0x00,0x00];
    // 0x61: a
    font[0x61] = [0x00,0x00,0x1E,0x30,0x3E,0x33,0x6E,0x00];
    // 0x62: b
    font[0x62] = [0x07,0x06,0x06,0x3E,0x66,0x66,0x3B,0x00];
    // 0x63: c
    font[0x63] = [0x00,0x00,0x3E,0x63,0x03,0x63,0x3E,0x00];
    // 0x64: d
    font[0x64] = [0x38,0x30,0x30,0x3E,0x33,0x33,0x6E,0x00];
    // 0x65: e
    font[0x65] = [0x00,0x00,0x3E,0x63,0x7F,0x03,0x3E,0x00];
    // 0x66: f
    font[0x66] = [0x1C,0x36,0x06,0x0F,0x06,0x06,0x0F,0x00];
    // 0x67: g
    font[0x67] = [0x00,0x00,0x6E,0x33,0x33,0x3E,0x30,0x1F];
    // 0x68: h
    font[0x68] = [0x07,0x06,0x36,0x6E,0x66,0x66,0x67,0x00];
    // 0x69: i
    font[0x69] = [0x0C,0x00,0x0E,0x0C,0x0C,0x0C,0x1E,0x00];
    // 0x6A: j
    font[0x6A] = [0x30,0x00,0x38,0x30,0x30,0x33,0x33,0x1E];
    // 0x6B: k
    font[0x6B] = [0x07,0x06,0x66,0x36,0x1E,0x36,0x67,0x00];
    // 0x6C: l
    font[0x6C] = [0x0E,0x0C,0x0C,0x0C,0x0C,0x0C,0x1E,0x00];
    // 0x6D: m
    font[0x6D] = [0x00,0x00,0x33,0x7F,0x7F,0x6B,0x63,0x00];
    // 0x6E: n
    font[0x6E] = [0x00,0x00,0x1F,0x33,0x33,0x33,0x33,0x00];
    // 0x6F: o
    font[0x6F] = [0x00,0x00,0x1E,0x33,0x33,0x33,0x1E,0x00];
    // 0x70: p
    font[0x70] = [0x00,0x00,0x3B,0x66,0x66,0x3E,0x06,0x0F];
    // 0x71: q
    font[0x71] = [0x00,0x00,0x6E,0x33,0x33,0x3E,0x30,0x78];
    // 0x72: r
    font[0x72] = [0x00,0x00,0x3B,0x6E,0x66,0x06,0x0F,0x00];
    // 0x73: s
    font[0x73] = [0x00,0x00,0x3E,0x03,0x1E,0x30,0x1F,0x00];
    // 0x74: t
    font[0x74] = [0x08,0x0C,0x3E,0x0C,0x0C,0x2C,0x18,0x00];
    // 0x75: u
    font[0x75] = [0x00,0x00,0x33,0x33,0x33,0x33,0x6E,0x00];
    // 0x76: v
    font[0x76] = [0x00,0x00,0x33,0x33,0x33,0x1E,0x0C,0x00];
    // 0x77: w
    font[0x77] = [0x00,0x00,0x63,0x6B,0x7F,0x7F,0x36,0x00];
    // 0x78: x
    font[0x78] = [0x00,0x00,0x63,0x36,0x1C,0x36,0x63,0x00];
    // 0x79: y
    font[0x79] = [0x00,0x00,0x33,0x33,0x33,0x3E,0x30,0x1F];
    // 0x7A: z
    font[0x7A] = [0x00,0x00,0x3F,0x19,0x0C,0x26,0x3F,0x00];
    // 0x7B: {
    font[0x7B] = [0x1C,0x0C,0x0C,0x07,0x0C,0x0C,0x1C,0x00];
    // 0x7C: |
    font[0x7C] = [0x0C,0x0C,0x0C,0x00,0x0C,0x0C,0x0C,0x00];
    // 0x7D: }
    font[0x7D] = [0x07,0x0C,0x0C,0x1C,0x0C,0x0C,0x07,0x00];
    // 0x7E: ~
    font[0x7E] = [0x00,0x00,0x08,0x1C,0x1C,0x08,0x00,0x00];
    // 0x7F:
    font[0x7F] = [0x78,0xCC,0xCC,0xCC,0xCC,0xCC,0x78,0x00];
    font
};



pub unsafe fn draw_char(fb_addr: u32, pitch: u32,x: u32, y: u32, ch: char, fg_color: u32, bg_color: Option<u32>) {
    let fb_ptr = fb_addr as *mut u32;
    if fb_ptr.is_null() || pitch == 0 {
        return; // Framebuffer not initialized.
    }
    let pitch_pixels = 1024; // Convert pitch from bytes to pixels.
    let x_usize = x as usize;
    let y_usize = y as usize;
    let glyph = FONT8X8[ch as usize];

    // Iterate over each row (8 rows for an 8x8 font).
    for row in 0..8 {
        let bits = glyph[row];
        for col in 0..8 {
            // Check if the pixel should be on.
            let pixel_on = ((bits >> col) & 1) != 0;
            //let pixel_on = ((bits >> (7 - col)) & 1) != 0;
            let pixel_index = ((y_usize + row) * pitch_pixels) + (x_usize + col);
            let pixel_ptr = fb_ptr.add(pixel_index);
            if pixel_on {
                write_volatile(pixel_ptr, fg_color);
            } else if let Some(bg) = bg_color {
                write_volatile(pixel_ptr, bg);
            }
        }
    }
}

/// Draws a string starting at (x, y). Newlines move the text down by 8 pixels.
pub unsafe fn draw_text(fb_addr: u32, pitch: u32,x: u32, y: u32, text: &str, fg_color: u32, bg_color: Option<u32>) {
    let mut x_pos = x;
    let mut y_pos = y;
    for ch in text.chars() {
        if ch == '\n' {
            x_pos = x;
            y_pos += 8; // Move down by the character height.
        } else {
            draw_char(fb_addr, pitch,x_pos, y_pos, ch, fg_color, bg_color);
            x_pos += 8; // Advance the cursor by the character width.
        }
    }
}
